# üß± Architecture Overview

The big picture of how Pillar pieces fit together ‚Äî including snapshots, streaming fetch strategies, and the `EventWindow` time/position bounds.

```mermaid
flowchart LR
  subgraph App["Your Laravel App"]
    U["Client / API"]
    CH["Command Handler"]
    QH["Query Handler"]
    F["Pillar Facade"]
    S["AggregateSession"]
    R["Repository"]
    PJ["Projectors"]
  end

  subgraph Infra["Infrastructure"]
    ES[(Event Store)]
    SS[(Snapshot Store)]
    SP["Snapshot Policy"]
    SER["Serializer (+ encryption)"]
    DB[(Read Model DB)]
  end

  %% Command flow
  U -->|send command| CH
  CH -->|load| S
  S -->|find| R
  R -->|load snapshot| SS
  R -->|load events| ES
  ES --> SER
  CH -->|record events| S
  S -->|commit| R
  R -->|append| ES
  ES -->|dispatch events| PJ
  PJ -->|upsert| DB
  SP -. decides when to snapshot .-> R
  R -->|save snapshot if needed| SS

  %% Query flow
  U -->|ask query| QH
  QH --> DB

  classDef core fill:#334155,stroke:#94a3b8,color:#e5e7eb
  classDef infra fill:#0f172a,stroke:#64748b,color:#e5e7eb
  classDef secondary fill:#1f2937,stroke:#6b7280,color:#e5e7eb

  class S,R core
  class ES,SS,SP,SER,DB infra
  class F,PJ secondary
```
---

## Key ideas

- **AggregateSession & Repository**  
  Your handler calls the session to `find(...)` an aggregate. The repository loads an optional snapshot and then streams events from the **Event Store** to rebuild state.  
  Repositories now resolve stream identifiers through the AggregateRegistry; no separate Stream Resolver exists.

- **Streaming reads (fetch strategies)**  
  `load()` yields events as generators (chunked, cursor-based, or load‚Äëall), letting you process large streams with minimal memory.

- **EventWindow ‚Äî load ‚Äúas of‚Äù a point in time**  
  All aggregate loads can be bounded using an optional `EventWindow`:
  - `afterStreamSequence`: start strictly *after* this stream_sequence (the repository sets this to the snapshot version automatically).
  - `toStreamSequence`: stop at a stream_sequence.
  - `toGlobalSequence`: stop at a specific global sequence.
  - `toDateUtc`: stop at a timestamp (UTC).
  
  This enables ‚Äúshow state at event X / at time T‚Äù without special APIs.  
  Stream IDs are readable tags such as 'document-<uuid>' generated by AggregateRegistry.

- **Snapshots (optional, policy‚Äëdriven)**  
  After a commit, the snapshot **policy** decides if the repository should persist a new snapshot to the **Snapshot Store** (cache or your own implementation).

- **Serializer (+ optional payload encryption)**  
  The base serializer (JSON by default) can be wrapped by an **encrypting** serializer with a pluggable cipher. Encryption can be enabled globally and overridden per event type.

- **Projectors & read models**  
  Stored events are dispatched to projectors to build queryable read models (in your DB of choice).  

- **Replays**  
  `pillar:replay-events` replays events to projectors (only), scoped by aggregate, type, or time/sequence windows.

---

## See also

- [Aggregate sessions](/concepts/aggregate-sessions)
- [Aggregate roots](/concepts/aggregate-roots)
- [Snapshotting](/concepts/snapshotting)
- [Event Store](/event-store/)
- [Serialization ‚Üí Payload encryption](/concepts/serialization#payload-encryption)
- [CLI ‚Äî Replay events](/reference/cli-replay)
